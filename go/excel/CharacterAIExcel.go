// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package excel

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type CharacterAIExcel struct {
	_tab flatbuffers.Table
}

func GetRootAsCharacterAIExcel(buf []byte, offset flatbuffers.UOffsetT) *CharacterAIExcel {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CharacterAIExcel{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCharacterAIExcel(buf []byte, offset flatbuffers.UOffsetT) *CharacterAIExcel {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CharacterAIExcel{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CharacterAIExcel) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CharacterAIExcel) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CharacterAIExcel) HasTargetSwitchingMotion() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *CharacterAIExcel) MutateHasTargetSwitchingMotion(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func (rcv *CharacterAIExcel) CanUseObstacleOfStandMotion() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *CharacterAIExcel) MutateCanUseObstacleOfStandMotion(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *CharacterAIExcel) CanUseObstacleOfKneelMotion() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *CharacterAIExcel) MutateCanUseObstacleOfKneelMotion(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *CharacterAIExcel) MinimumPositionGap() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateMinimumPositionGap(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *CharacterAIExcel) DistanceReduceFormationPath() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateDistanceReduceFormationPath(n int64) bool {
	return rcv._tab.MutateInt64Slot(12, n)
}

func (rcv *CharacterAIExcel) DistanceReduceRatioFormationPath() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateDistanceReduceRatioFormationPath(n int64) bool {
	return rcv._tab.MutateInt64Slot(14, n)
}

func (rcv *CharacterAIExcel) DistanceReduceObstaclePath() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateDistanceReduceObstaclePath(n int64) bool {
	return rcv._tab.MutateInt64Slot(16, n)
}

func (rcv *CharacterAIExcel) DistanceReduceRatioObstaclePath() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateDistanceReduceRatioObstaclePath(n int64) bool {
	return rcv._tab.MutateInt64Slot(18, n)
}

func (rcv *CharacterAIExcel) CheckCanUseAutoSkill() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *CharacterAIExcel) MutateCheckCanUseAutoSkill(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

func (rcv *CharacterAIExcel) Positioning() PositioningType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return PositioningType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CharacterAIExcel) MutatePositioning(n PositioningType) bool {
	return rcv._tab.MutateInt32Slot(22, int32(n))
}

func (rcv *CharacterAIExcel) EngageType() EngageType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return EngageType(rcv._tab.GetInt32(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateEngageType(n EngageType) bool {
	return rcv._tab.MutateInt32Slot(24, int32(n))
}

func (rcv *CharacterAIExcel) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CharacterAIExcel) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(26, n)
}

func CharacterAIExcelStart(builder *flatbuffers.Builder) {
	builder.StartObject(12)
}
func CharacterAIExcelAddHasTargetSwitchingMotion(builder *flatbuffers.Builder, hasTargetSwitchingMotion bool) {
	builder.PrependBoolSlot(0, hasTargetSwitchingMotion, false)
}
func CharacterAIExcelAddCanUseObstacleOfStandMotion(builder *flatbuffers.Builder, canUseObstacleOfStandMotion bool) {
	builder.PrependBoolSlot(1, canUseObstacleOfStandMotion, false)
}
func CharacterAIExcelAddCanUseObstacleOfKneelMotion(builder *flatbuffers.Builder, canUseObstacleOfKneelMotion bool) {
	builder.PrependBoolSlot(2, canUseObstacleOfKneelMotion, false)
}
func CharacterAIExcelAddMinimumPositionGap(builder *flatbuffers.Builder, minimumPositionGap int64) {
	builder.PrependInt64Slot(3, minimumPositionGap, 0)
}
func CharacterAIExcelAddDistanceReduceFormationPath(builder *flatbuffers.Builder, distanceReduceFormationPath int64) {
	builder.PrependInt64Slot(4, distanceReduceFormationPath, 0)
}
func CharacterAIExcelAddDistanceReduceRatioFormationPath(builder *flatbuffers.Builder, distanceReduceRatioFormationPath int64) {
	builder.PrependInt64Slot(5, distanceReduceRatioFormationPath, 0)
}
func CharacterAIExcelAddDistanceReduceObstaclePath(builder *flatbuffers.Builder, distanceReduceObstaclePath int64) {
	builder.PrependInt64Slot(6, distanceReduceObstaclePath, 0)
}
func CharacterAIExcelAddDistanceReduceRatioObstaclePath(builder *flatbuffers.Builder, distanceReduceRatioObstaclePath int64) {
	builder.PrependInt64Slot(7, distanceReduceRatioObstaclePath, 0)
}
func CharacterAIExcelAddCheckCanUseAutoSkill(builder *flatbuffers.Builder, checkCanUseAutoSkill bool) {
	builder.PrependBoolSlot(8, checkCanUseAutoSkill, false)
}
func CharacterAIExcelAddPositioning(builder *flatbuffers.Builder, positioning PositioningType) {
	builder.PrependInt32Slot(9, int32(positioning), 0)
}
func CharacterAIExcelAddEngageType(builder *flatbuffers.Builder, engageType EngageType) {
	builder.PrependInt32Slot(10, int32(engageType), 0)
}
func CharacterAIExcelAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(11, id, 0)
}
func CharacterAIExcelEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
