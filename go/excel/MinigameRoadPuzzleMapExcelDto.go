// Code generated by fbsgen. DO NOT EDIT.
// Package excel contains generated code for FlatBuffers schema
package excel

import (
	fbsutils "github.com/arisu-archive/bluearchive-fbs-utils"
	flatbuffers "github.com/google/flatbuffers/go"
)

// MinigameRoadPuzzleMapExcelDto represents a FlatBuffers table
type MinigameRoadPuzzleMapExcelDto struct {
	fbsutils.FlatBuffer
	AvailableRailTileAmount []int64 `json:"available_rail_tile_amount"`
	AvailableRailTile       []int64 `json:"available_rail_tile"`
	BgmId                   int64   `json:"bgm_id"`
	EventContentId          int64   `json:"event_content_id"`
	Map                     string  `json:"map"`
	MapBg                   string  `json:"map_bg"`
	MapGroupId              int64   `json:"map_group_id"`
	OriginalTileCount       []int64 `json:"original_tile_count"`
	TrainSpeed              float32 `json:"train_speed"`
	UniqueId                int64   `json:"unique_id"`
}

// MarshalModel marshals the struct into flatbuffers offset
func (t *MinigameRoadPuzzleMapExcelDto) MarshalModel(b *flatbuffers.Builder) flatbuffers.UOffsetT {
	MinigameRoadPuzzleMapExcelStart(b)
	MinigameRoadPuzzleMapExcelStartAvailableRailTileAmountVector(b, len(t.AvailableRailTileAmount))
	for i := range len(t.AvailableRailTileAmount) {
		b.PrependInt64(fbsutils.Convert(t.AvailableRailTileAmount[len(t.AvailableRailTileAmount)-i-1], t.FlatBuffer.TableKey))
	}
	MinigameRoadPuzzleMapExcelAddAvailableRailTileAmount(b, b.EndVector(len(t.AvailableRailTileAmount)))
	MinigameRoadPuzzleMapExcelStartAvailableRailTileVector(b, len(t.AvailableRailTile))
	for i := range len(t.AvailableRailTile) {
		b.PrependInt64(fbsutils.Convert(t.AvailableRailTile[len(t.AvailableRailTile)-i-1], t.FlatBuffer.TableKey))
	}
	MinigameRoadPuzzleMapExcelAddAvailableRailTile(b, b.EndVector(len(t.AvailableRailTile)))
	MinigameRoadPuzzleMapExcelAddBgmId(b, fbsutils.Convert(t.BgmId, t.FlatBuffer.TableKey))
	MinigameRoadPuzzleMapExcelAddEventContentId(b, fbsutils.Convert(t.EventContentId, t.FlatBuffer.TableKey))
	MinigameRoadPuzzleMapExcelAddMap(b, b.CreateString(fbsutils.Convert(t.Map, t.FlatBuffer.TableKey)))
	MinigameRoadPuzzleMapExcelAddMapBg(b, b.CreateString(fbsutils.Convert(t.MapBg, t.FlatBuffer.TableKey)))
	MinigameRoadPuzzleMapExcelAddMapGroupId(b, fbsutils.Convert(t.MapGroupId, t.FlatBuffer.TableKey))
	MinigameRoadPuzzleMapExcelStartOriginalTileCountVector(b, len(t.OriginalTileCount))
	for i := range len(t.OriginalTileCount) {
		b.PrependInt64(fbsutils.Convert(t.OriginalTileCount[len(t.OriginalTileCount)-i-1], t.FlatBuffer.TableKey))
	}
	MinigameRoadPuzzleMapExcelAddOriginalTileCount(b, b.EndVector(len(t.OriginalTileCount)))
	MinigameRoadPuzzleMapExcelAddTrainSpeed(b, fbsutils.Convert(t.TrainSpeed, t.FlatBuffer.TableKey))
	MinigameRoadPuzzleMapExcelAddUniqueId(b, fbsutils.Convert(t.UniqueId, t.FlatBuffer.TableKey))
	return MinigameRoadPuzzleMapExcelEnd(b)
}

// Marshal marshals the struct into a FlatBuffers buffer
func (t *MinigameRoadPuzzleMapExcelDto) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(t.MarshalModel(b))
	return b.FinishedBytes(), nil
}

// UnmarshalMessage unmarshals the struct from a FlatBuffers buffer
func (t *MinigameRoadPuzzleMapExcelDto) UnmarshalMessage(e *MinigameRoadPuzzleMapExcel) error {
	t.AvailableRailTileAmount = make([]int64, e.AvailableRailTileAmountLength())
	for i := range e.AvailableRailTileAmountLength() {
		t.AvailableRailTileAmount[i] = fbsutils.Convert(e.AvailableRailTileAmount(i), t.FlatBuffer.TableKey)
	}
	t.AvailableRailTile = make([]int64, e.AvailableRailTileLength())
	for i := range e.AvailableRailTileLength() {
		t.AvailableRailTile[i] = fbsutils.Convert(e.AvailableRailTile(i), t.FlatBuffer.TableKey)
	}
	t.BgmId = fbsutils.Convert(e.BgmId(), t.FlatBuffer.TableKey)
	t.EventContentId = fbsutils.Convert(e.EventContentId(), t.FlatBuffer.TableKey)
	t.Map = fbsutils.Convert(string(e.Map()), t.FlatBuffer.TableKey)
	t.MapBg = fbsutils.Convert(string(e.MapBg()), t.FlatBuffer.TableKey)
	t.MapGroupId = fbsutils.Convert(e.MapGroupId(), t.FlatBuffer.TableKey)
	t.OriginalTileCount = make([]int64, e.OriginalTileCountLength())
	for i := range e.OriginalTileCountLength() {
		t.OriginalTileCount[i] = fbsutils.Convert(e.OriginalTileCount(i), t.FlatBuffer.TableKey)
	}
	t.TrainSpeed = fbsutils.Convert(e.TrainSpeed(), t.FlatBuffer.TableKey)
	t.UniqueId = fbsutils.Convert(e.UniqueId(), t.FlatBuffer.TableKey)
	return nil
}

// Unmarshal unmarshals the struct from a FlatBuffers buffer
func (t *MinigameRoadPuzzleMapExcelDto) Unmarshal(data []byte) error {
	root := GetRootAsMinigameRoadPuzzleMapExcel(data, 0)
	err := t.UnmarshalMessage(root)
	if err != nil {
		return err
	}
	return nil
}

// Name returns the name of the flatbuffer table name
func (MinigameRoadPuzzleMapExcelDto) FlatDataName() string {
	return "MinigameRoadPuzzleMapExcel"
}
