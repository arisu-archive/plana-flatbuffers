// Code generated by fbsgen. DO NOT EDIT.
// Package flatdata contains generated code for FlatBuffers schema
package flatdata

import (
	fbsutils "github.com/arisu-archive/bluearchive-fbs-utils"
	flatbuffers "github.com/google/flatbuffers/go"
)

// CharacterWeaponExcelDto represents a FlatBuffers table
type CharacterWeaponExcelDto struct {
	fbsutils.FlatBuffer
	Id              int64                 `json:"id"`
	ImagePath       string                `json:"image_path"`
	SetRecipe       int64                 `json:"set_recipe"`
	StatLevelUpType StatLevelUpType       `json:"stat_level_up_type"`
	AttackPower     int64                 `json:"attack_power"`
	AttackPower100  int64                 `json:"attack_power100"`
	MaxHp           int64                 `json:"max_hp"`
	MaxHp100        int64                 `json:"max_hp100"`
	HealPower       int64                 `json:"heal_power"`
	HealPower100    int64                 `json:"heal_power100"`
	Unlock          []bool                `json:"unlock"`
	RecipeId        []int64               `json:"recipe_id"`
	MaxLevel        []int32               `json:"max_level"`
	LearnSkillSlot  []string              `json:"learn_skill_slot"`
	StatType        []EquipmentOptionType `json:"stat_type"`
	StatValue       []int64               `json:"stat_value"`
}

// MarshalModel marshals the struct into flatbuffers offset
func (t *CharacterWeaponExcelDto) MarshalModel(b *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("CharacterWeapon"))
	}
	CharacterWeaponExcelStart(b)
	CharacterWeaponExcelAddId(b, fbsutils.Convert(t.Id, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddImagePath(b, b.CreateString(fbsutils.Convert(t.ImagePath, t.FlatBuffer.TableKey)))
	CharacterWeaponExcelAddSetRecipe(b, fbsutils.Convert(t.SetRecipe, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddStatLevelUpType(b, fbsutils.Convert(t.StatLevelUpType, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddAttackPower(b, fbsutils.Convert(t.AttackPower, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddAttackPower100(b, fbsutils.Convert(t.AttackPower100, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddMaxHp(b, fbsutils.Convert(t.MaxHp, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddMaxHp100(b, fbsutils.Convert(t.MaxHp100, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddHealPower(b, fbsutils.Convert(t.HealPower, t.FlatBuffer.TableKey))
	CharacterWeaponExcelAddHealPower100(b, fbsutils.Convert(t.HealPower100, t.FlatBuffer.TableKey))
	CharacterWeaponExcelStartUnlockVector(b, len(t.Unlock))
	for i := range len(t.Unlock) {
		b.PrependBool(t.Unlock[len(t.Unlock)-i-1])
	}
	CharacterWeaponExcelAddUnlock(b, b.EndVector(len(t.Unlock)))
	CharacterWeaponExcelStartRecipeIdVector(b, len(t.RecipeId))
	for i := range len(t.RecipeId) {
		b.PrependInt64(fbsutils.Convert(t.RecipeId[len(t.RecipeId)-i-1], t.FlatBuffer.TableKey))
	}
	CharacterWeaponExcelAddRecipeId(b, b.EndVector(len(t.RecipeId)))
	CharacterWeaponExcelStartMaxLevelVector(b, len(t.MaxLevel))
	for i := range len(t.MaxLevel) {
		b.PrependInt32(fbsutils.Convert(t.MaxLevel[len(t.MaxLevel)-i-1], t.FlatBuffer.TableKey))
	}
	CharacterWeaponExcelAddMaxLevel(b, b.EndVector(len(t.MaxLevel)))
	CharacterWeaponExcelStartLearnSkillSlotVector(b, len(t.LearnSkillSlot))
	for i := range len(t.LearnSkillSlot) {
		b.PrependUOffsetT(b.CreateString(t.LearnSkillSlot[len(t.LearnSkillSlot)-i-1]))
	}
	CharacterWeaponExcelAddLearnSkillSlot(b, b.EndVector(len(t.LearnSkillSlot)))
	CharacterWeaponExcelStartStatTypeVector(b, len(t.StatType))
	for i := range len(t.StatType) {
		b.PrependInt32(fbsutils.Convert(int32(t.StatType[len(t.StatType)-i-1]), t.FlatBuffer.TableKey))
	}
	CharacterWeaponExcelAddStatType(b, b.EndVector(len(t.StatType)))
	CharacterWeaponExcelStartStatValueVector(b, len(t.StatValue))
	for i := range len(t.StatValue) {
		b.PrependInt64(fbsutils.Convert(t.StatValue[len(t.StatValue)-i-1], t.FlatBuffer.TableKey))
	}
	CharacterWeaponExcelAddStatValue(b, b.EndVector(len(t.StatValue)))
	return CharacterWeaponExcelEnd(b)
}

// Marshal marshals the struct into a FlatBuffers buffer
func (t *CharacterWeaponExcelDto) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(t.MarshalModel(b))
	return b.FinishedBytes(), nil
}

// UnmarshalMessage unmarshals the struct from a FlatBuffers buffer
func (t *CharacterWeaponExcelDto) UnmarshalMessage(e *CharacterWeaponExcel) error {
	if t.FlatBuffer.TableKey == nil {
		t.FlatBuffer.InitKey(fbsutils.CreateTableKey("CharacterWeapon"))
	}
	t.Id = fbsutils.Convert(e.Id(), t.FlatBuffer.TableKey)
	t.ImagePath = fbsutils.Convert(string(e.ImagePath()), t.FlatBuffer.TableKey)
	t.SetRecipe = fbsutils.Convert(e.SetRecipe(), t.FlatBuffer.TableKey)
	t.StatLevelUpType = StatLevelUpType(fbsutils.Convert(int32(e.StatLevelUpType()), t.FlatBuffer.TableKey))
	t.AttackPower = fbsutils.Convert(e.AttackPower(), t.FlatBuffer.TableKey)
	t.AttackPower100 = fbsutils.Convert(e.AttackPower100(), t.FlatBuffer.TableKey)
	t.MaxHp = fbsutils.Convert(e.MaxHp(), t.FlatBuffer.TableKey)
	t.MaxHp100 = fbsutils.Convert(e.MaxHp100(), t.FlatBuffer.TableKey)
	t.HealPower = fbsutils.Convert(e.HealPower(), t.FlatBuffer.TableKey)
	t.HealPower100 = fbsutils.Convert(e.HealPower100(), t.FlatBuffer.TableKey)
	t.Unlock = make([]bool, e.UnlockLength())
	for i := range e.UnlockLength() {
		t.Unlock[i] = e.Unlock(i)
	}
	t.RecipeId = make([]int64, e.RecipeIdLength())
	for i := range e.RecipeIdLength() {
		t.RecipeId[i] = fbsutils.Convert(e.RecipeId(i), t.FlatBuffer.TableKey)
	}
	t.MaxLevel = make([]int32, e.MaxLevelLength())
	for i := range e.MaxLevelLength() {
		t.MaxLevel[i] = fbsutils.Convert(e.MaxLevel(i), t.FlatBuffer.TableKey)
	}
	t.LearnSkillSlot = make([]string, e.LearnSkillSlotLength())
	for i := range e.LearnSkillSlotLength() {
		t.LearnSkillSlot[i] = fbsutils.Convert(string(e.LearnSkillSlot(i)), t.FlatBuffer.TableKey)
	}
	t.StatType = make([]EquipmentOptionType, e.StatTypeLength())
	for i := range e.StatTypeLength() {
		t.StatType[i] = EquipmentOptionType(fbsutils.Convert(int32(e.StatType(i)), t.FlatBuffer.TableKey))
	}
	t.StatValue = make([]int64, e.StatValueLength())
	for i := range e.StatValueLength() {
		t.StatValue[i] = fbsutils.Convert(e.StatValue(i), t.FlatBuffer.TableKey)
	}
	return nil
}

// Unmarshal unmarshals the struct from a FlatBuffers buffer
func (t *CharacterWeaponExcelDto) Unmarshal(data []byte) error {
	root := GetRootAsCharacterWeaponExcel(data, 0)
	err := t.UnmarshalMessage(root)
	if err != nil {
		return err
	}
	return nil
}

// Name returns the name of the flatbuffer table name
func (CharacterWeaponExcelDto) FlatDataName() string {
	return "CharacterWeaponExcel"
}
